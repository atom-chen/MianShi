1.操作符的优先级和结合性只影响操作符的执行顺序，不影响操作数的求值顺序。
例如，A()+B()*C();
在C++中，不同的编译器可以有选择以不同顺序求值函数调用，但是C#只能是从左向右求值。
在C++中，对于M(x++,x++)这样的调用，假定x初值为1，那么既可以调用M(1,2)，又可以调用M(2,1)，具体由编译器决定。
C#则总是调用M(1,2)，因为C#做了两点保证，第一，传给调用的实参总是从左到右计算。第二，总是先将被递增的值赋给变量，再使用表达式的值，所以第一个参数，C#会先把x=1赋值给第一个形参，然后再计算表达式。
在C、C++和C#之间移植使用递增和递减操作符的代码时要小心，C和C++的实现规则可能不同。

2.空接合操作符 ??
expression1 ?? expression2
如果expression1不为null，就返回它的值，否则返回expression2的值。

3.null条件操作符 ?.
null条件操作符在调用方法或属性前检查操作数是否为null。
检查arg[];
if(arg?.Length==0)
这个操作符等同于 (args != null) ? (int?) arg.Length : null;
当调用的成员返回的是一个值类型时，要用到该类型的空类型。
null条件操作符也可以和索引操作符结合使用
数组array，b=array?[1];

3.C++switch语句贯穿，会导致一些常见的bug。
C#不允许控制从一个小节自然贯穿到下一个小节。

4.C#预处理指令
C#预处理器在编译时调用，它告诉编译器要编译哪些代码，并指出如何处理代码中的特定错误和警告，还可以告诉编译器有关代码组织的信息。
C/C++的预处理器告诉编译器如何编译文件中的代码，而并不参与实际的编译过程。相反，C#编译器将预处理器指令作为代码词法分析的一部分。
#define指令
#error和#warning指令，为了标记代码中潜在的问题，可以插入#error和#warning指令来分别生成错误和警告。
#region和#endregion必须成对使用。