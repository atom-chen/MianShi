1.字面量/字面值--literal value：表示源代码中的固定值
直接将值放到源代码中成为硬编码，如果以后需要修改值则需要重新编译，会为维护带来不便，可以考虑从外部来源获取值。

2.反斜杠和特殊字符代码组成转义序列。

3.var，用来声明隐式类型的局部变量，由编译器根据声明所赋的值推断数据类型。

4.可空修饰符
一般不能将null赋给值类型，但如果值确实应该怎么办，为了声明可以存储null的变量，要使用可空修饰符？。
int? count=null;
while(count==null)

5.数据类型转换--显式转型和隐式转型
显式转型：有可能造成大小变小或者引发异常的任何转换都需要执行显式转型，通过括号指定希望转换成的类型，表面已经认可显示转型时可能丢失精度和数据，或者可能造成异常。
隐式转型：不会造成变小且不会引发异常的任何转换都属于隐式转换。

C#提供了特殊关键字来标识代码块，对数据转换的异常进行处理。
C#提供了特殊关键字来标识代码块，指出假如目标数据类型太小，以至于容不下赋值的数据，那么回发生什么情况。
将转换代码放入到checked{}块中，或者在编译时使用checked选项，就会使“运行时”引发SystemOverflowException异常。
C#支持unchecked块，它强制不进行溢出检查，即使在编译时打开了checked选项，unchecked关键字也会阻止引发异常。

不使用转型操作符的类型转换
每个数值数据类型都包含一个Parse()方法，它允许将字符串转换成对应的数值类型。
所有的类型都支持ToString()方法。对于大多数类型，ToString方法只是返回数据类型的名称而不是数据的字符串表示。只有在类型显式实现了ToString()的前提下才会返回字符串表示。
所有基元数值类型都包含静态TryParse()方法，该方法与Parse()方法类似，只是如果转换失败，它不引发异常而是返回false。
if( double.TryParse(input,out number) )

6.数组
C#，作为数组声明一部分的方括号是紧跟在数据类型之后的，而不是出现在变量声明之后，可以确保所有类型信息都放在一起。
数组是引用类型，可以通过Length获得数组的长度
缓冲区溢出错误：非托管的C++并非总是检查是否越过数组边界，可能会造成潜在的安全问题，这就是缓冲区溢出。
更多的数组方法，Sort()和Clear()。

7.字符串作为数组使用
访问string类型的变量类似于访问字符数组。