1.多线程处理主要用于两个方面：实现多任务和解决延迟。

2.任务是可能有高延迟的工作单元，它是由Task类的实例表示，都在System.Threading.Tasks命名空间中。

3.多线程基础
内存隔离：CLR给每个线程分配自己内存栈，因此局部变量可以保持分离。
数据共享：如果多个线程对同一个对象实例有相同的引用，这些线程就共享这个对象实例的数据，全局变量也是数据共享的。注意：在多线程中，共享数据是造成复杂原因的主要，而且会产生让人费	解的错误。尽管很基本但还是要尽可能保持简单。
线程安全：线程安全就是说多线程访问同一代码，不会产生不确定的结果。编写线程安全的代码是依靠线程同步，例如：当读\写一个公共字段时，获取一个独占锁（exclusive lock）。C#提供了关键字lock。当两个线程同时抢占一个锁时（在这个例子中，locker）,一个线程等待，或者阻塞，直到这个锁释放。在这个例子中，这个锁保证一次只有一个线程可以进入代码的临界区域，然后“Done”只会被打印一次。代码在这种不确定的多线程背景下中被保护被叫做线程安全。
常见的线程安全的类：
原子操作：如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行，这种特性就叫原子性，原子操作要么尚未开始，要么完全结束，经典案例就是银行转账。

4.sleep和join
当使用Sleep或Join暂停线程时，这个线程是阻塞的，不消耗CPU资源。

Thread类的Join()方法
　　由运行结果可以看出，一开始两个线程交替进行，当线程B执行到语句“ThreadA.Join()”时，线程A被插入到线程B之前，两个线程合并到一起，变为顺序执行，直到执行完线程A中的所有语句，才去执行线程B中剩余的语句。
　　换句话说，当我们在线程B中调用ThreadA.Join()时，该方法只有在线程ThreadA执行完毕之后才会返回。Join()函数还可以接受一个表示毫秒数的参数，当达到指定时间后，如果线程A还没运行完毕，那么Join函数将返回，这时线程A和线程B再次处于交替运行状态中。

Thread.Sleep 暂停当前线程一段指定的时间；Thread.Sleep(0)立即放弃这个线程的时间片，主动交出CPU给其他线程。

5.线程的工作原理

6.锁定与死锁
C#主要靠lock语句的锁定机制来解决非原子操作等多线程问题。
