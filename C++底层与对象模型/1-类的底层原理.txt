我们首先从一个问题来阐明类的底层机理：
假如有一个类A，里面有一个成员函数get(),例如：
class A
{
public:
    void get();
}
A a;
那么a.get()表示什么呢？首先给出答案是get(&a),因为在类的底层机制中，成员函数的第一个参数都是一个指向该类数据结构的指针（静态成员函数除外），所以成员函数get()的存在形式为void get(A* this);这也能说明为什么我们在成员函数的定义中总是可以用this来指代调用对象。
我们知道，要使用一个C++类，必要的条件是在编译期能得到这个类的头文件，并在链接期可以找到对应的符号的链接地址（比如成员函数、静态数据成员等）。如果这个C++类与你的使用者在同一个工程，那这个条件很好满足：
首先，C++类的头文件很好获得。直接在使用者那里将类的头文件include即可；
其次，C++类往往被编译器作为一个编译单元，生成一个obj文件。在最后进行链接的过程中，链接器会把工程中所有的obj链接以生成最终的二进制目标文件。所以链接器在遇到一处对类成员函数（或其它形式的符号引用）时，会在这个类生成的obj文件中找到符号的链接地址。
那么，在代码中使用一个C++类，编译期和链接期需要的到底是些什么东西呢？换句话说，满足了什么样的条件，编译器和链接器就不会抱怨了呢？
根据C++语言的定义，一个C++类实际上是声明或定义了如下几类内容：
1.声明了一个数据结构，类中的非静态数据成员、代码中看不到但如果有虚函数就会生成的虚表入口地址指针等。
2.声明并定义了一堆函数，它们第一个参数都是一个指向这个数据结构的指针。这些实际上就是类中那些非静态成员函数（包括虚函数），它们虽然在类声明中是写在类的一对大括号内部，但实际上没有任何东西被加到前面第1条中所说的内部数据结构中。实际上，这样的声明只是为这些函数增加了两个属性：函数名标识符的作用域被限制在类中；函数第一个参数是this，被省略不写了。
3.声明并定义了另一堆函数，它们看上去就是一些普通函数，与这个类几乎没有关系。这些实际上就是类中那些静态函数，它们也是一样，不会在第1条中所说的内部数据结构中增加什么东西，只是函数名标识符的作用域被限制在类中。
4.声明并定义了一堆全局变量。这些实际上就是类中那些静态数据成员。
5.声明并定义了一个全局变量，此全局变量是一个函数指针数组，用来保存此类中所有的虚函数的入口地址。当然，这个全局变量生成的前提是这个类有虚函数。
看下面的一个例子：
class MyClass
{
public:
    int x;
    int y;
    void Foo();
    void Bar(int newX, int newY);
    virtual void VFoo();
    virtual void VBar(int newX, int newY) = 0;
    static void SFoo();
    static void SBar(int newX, int newY);
    static int sx;
    static int sy;
};
对于上面列出的这个类MyClass，C++编译器多数会以如下的方式进行编译：
编译器生成的类的二进制结构
现在我们再来看一下为什么编译器需要头文件和符号地址就可以编译链接一个使用MyClass的程序了。
首先，由于编译器需要在编译期就知道类的内存布局，以保证可以生成正确的开辟内存的代码，及那些
sizeof(MyClass)的值。有了头文件，编译器就知道，一个MyClass占用12字节的内存空间（见上图，两个整数和一
个指针）。
其次，在调用MyClass的成员函数、静态函数时，链接器需要知道这些函数的入口地址，如果无法提供入口地址，
链接器就会报错。
最后，在引用MyClass的静态数据成员时，实际上与引用一个外部全局对象一样，链接器需要知道这些变量的地址。
如果无法提供这些变量的地址，链接器也会报错。
可以看出：
1. 编译期：必须要提供的是类的头文件，以使编译器可以得知类实例的尺寸和内存布局。
2. 链接期：必须要提供的是程序中引用过的，类的成员函数、静态函数、静态数据成员的地址，以使链接器可以正确的生成最终程序。
到这里，我们可以猜到，实际上，导出一个类，编译器实际上只需要将这个类中的：成员函数、静态函数、静态数
据成员当成普通的函数、全局变量导出即可。也就是说，我们实际上没有“导出一个类”，而是把这个类中需要被
引用的“有定义的实体”的入口地址像普通函数和变量那样正常导出即可。由于里面的纯虚函数VBar没有
定义，所以不会被导出。