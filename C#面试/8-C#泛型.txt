1.泛型是概念, 模板是泛型的实现
         泛型编程让你编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。泛型编程的代表作品STL是一种高效、泛型、可交互操作的软件组件。所谓泛型(Genericity)，是指具有在多种数据类型上皆可操作的含意，与模板有些相似。STL巨大，而且可以扩充，它包含很多计算机基本算法和数据结构，而且将算法与数据结构完全分离，其中算法是泛型的，不与任何特定数据结构或对象类型系在一起。STL以迭代器(Iterators)和容器(Containers)为基础，是一种泛型算法(Generic Algorithms)库，容器的存在使这些算法有东西可以操作。STL包含各种泛型算法(algorithms)、泛型指针(iterators)、泛型容器(containers)以及函数对象(function objects)。STL并非只是一些有用组件的集合，它是描述软件组件抽象需求条件的一个正规而有条理的架构。

2.泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。泛型类是引用类型，是堆对象，主要是引入了类型参数这个概念。
泛型其实是一种为了减少我们代码量而引入的一种模板，在这个模板中主要封装一些特殊的算法，让我们可以在处理一些不同类型的数据但对数据的处理具有相同的逻辑算法时，只需要写出一个模板，就可以处理多种数据类型的方法，无需为每种类型都写一个处理方法

3.泛型类和object类区别
针对object类型栈的问题，我们引入泛型，他可以优雅地解决这些问题。泛型用用一个通过的数据类型T来代替object，在类实例化时指定T的类型，运行时（Runtime）自动编译为本地代码，运行效率和代码质量都有很大提高，并且保证数据类型安全。
这个类和Object实现的类有截然不同的区别：
A.它是类型安全的。实例化了int类型的栈，就不能处理String类型的数据，其他的数据类型也一样。
B.无需装箱和拆箱。这个类在实例化时，按照所传入的数据类型生成本地代码，本地代码数据类型已确定，所以无需装箱和拆箱。
C.无需类型转换。

例如Dictionary是泛型容器，它在定义时要制定数据类型，一旦制定int型，就不能处理string类型的数据。

4.C#本质论
System.Collection.Stack，这个类不是一个泛型类，它是一个对象集合。
在不用泛型的情况下如果要创建支持多种数据类型的类，就选哟让它们支持一个公共基类，通常就是object。
C#是鼓励类型安全的，但是Stack类却不是。
泛型的类型参数的命名应该尽量具有描述性。

5.泛型的内部机制
泛型需要来自底层“运行时”的支持，将泛型引入C#语言，既是编译器的特性，又是平台的特性，这一点和java不同，java的泛型完全由编译器来支持的。
泛型的CIL：泛型的CIL代码和普通类无多大区别，只是泛型类的头部包含元数（类型参数的数量）和类型参数，并在泛型类的代码中庸感叹号指出类型参数。泛型的CIL是参数化的，接受在代码中别的地方由用户提供的类型。

基于值类型的泛型的实例化：用值类型作为类型参数首次构造一个泛型类型时，“运行时”会将指定的值类型参数放到CIL中合适的位置，从而创建一个具体化的泛型类型。以后如果再使用同一个值类型，那么“运行时”都会重用已经具体化的泛型类型。但是，如果使用了一个不同的值类型参数，那么就要重新生成相应的泛型类型
基于引用类型的泛型的实例化：使用引用类型参数第一次构造一个泛型类型时，“运行时”会用object引用类型来创建一个具体化的泛型类型。之后，每次使用类型参数进行泛型的实例化，即使类型参数不同，但都会重用第一次生成好的泛型类型。