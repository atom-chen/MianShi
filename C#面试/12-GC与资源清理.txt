1.垃圾回收过程只关注内存管理，对于文件句柄和数据库连接等资源，由终结器来清理。
终结器允许程序员编码来清理类的资源，但是终结器不能显式调用，只能由GC调用，但调用时间无法确定，只知道，垃圾回收器调用终结器是在对象最后一次使用之后、应用程序关闭之前的某个时间。
终结器不传递任何参数，所以它不能重载。

2.C#的终结器，与C++的析构函数不同，终结器不是在一个对象的所有引用消失后就马上运行。相反，终结器在对象被判定为“不可达”之后的不确定时间内执行。
过程细节：垃圾回收器会在一次垃圾回收过程中识别出所有带有终结器的对象，但不是立即回收这些对象，而是将它们添加到一个终结队列中。然后会有一个独立的线程比遍历终结队列中的每一个对象，调用其终结器，然后将其从队列中删除，使其再次可供垃圾回收器处理。
终结器是在自己的线程中执行，这使它们的执行更加不确定。

3.确定性终结---可以预知资源清理在何时运行
终结器只是对资源进行清理的备用机制，当开发者忘记显式调用必要的清理代码，这时就得依赖终结器清理资源。
所以，有必要提供进行确定性终结的方法，并在需要清理时进行显式调用。
但是即使开发者忘记调用显式方法，终结器也会调用显式方法，只是终结器比开发者的显式调用要晚一些，但是这个确定性的方法还是会被调用。