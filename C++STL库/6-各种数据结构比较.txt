1.需要大量添加新元素：
vector在大量添加元素的时候问题最大，因为他的一种最常见的内存分配实现方法是当前的容量(capacity)不足就申请一块当前容量2倍的新内存空间，然后将所有的老元素全部拷贝到新内存中，添加大量元素的时候的花费的惊人的大。如果由于其他因素必须使用vector，并且还需要大量添加新元素，那么可以使用成员函数reserve来事先分配内存，这样可以减少很多不必要的消耗。

list对这种情况的适应能力就非常好，都是常数时间的插入消耗。deque前面说过了，他是vector和list的折衷形式，内存不够了就申请一块新的内存，但并不拷贝老的元素。


2.查找速度：
这个因素主要取决于算法，而算法最终是作用在容器中元素上的，所以这里的查找速度指的是容器能够达到的最好查找效率。

对于序列容器需要分两种情况，区分依据是元素是否排序，1)对于已经排序的序列容器，使用binary_search、lower_bound、upper_bound、equal_range可以获得对数时间复杂度的查找速度(O(logN));2)而未排序的序列容器二分查找肯定是用不了，能达到的最好的时间复杂度是线性的(O(n))。

对于关联容器，存储的时候存储的是一棵红黑树(一种更为严格的平衡二叉树,文档最后有介绍)，总是能达到对数时间复杂度(O(logN))的效率，因为关联容器是按照键值排好序的。


3.是否是连续内存：
连续内存的容器有个明显的缺点，就是有新元素插入或老元素删除的时候，为了给新元素腾出位置或者填充老元素的空缺，同一块内存中的其他数据需要进行整体的移位，这种移位的拷贝代价有时是非常巨大的。标准容器中的vector、deque是连续内存的，其中vector是完全连续内存，而deque是vector和list的折衷实现，是多个内存块组成的，每个块中存放的元素连续内存，而内存块又像链表一样连接起来。

　　所以需要考虑在操作的过程中是否有在任意位置插入元素的需求，有这种需求的话尽量避免使用连续内存的vector、deque


4.元素的排序：
序列容器中的元素不会自动排序，程序员插入什么顺序内存中就是什么顺序，而关联容器不是这样的，他会以自己的键值按照某种等价关系(equivalence)进行排序。所以默认情况下序列容器中的元素是无序的，而关联容器中的元素是有序的。

所以容器在遍历元素的时候序列容器输出的顺序和插入的顺序式一致的，关联容器就不一定了。下面给出两个例子：

　　通过例子看到序列容器vector遍历的顺序和插入的顺序是一样的，而关联容器set把插入的元素按照某种顺序重新组织了，所以选择容器的时候如果很在意插入顺序的话就选择序列容器。