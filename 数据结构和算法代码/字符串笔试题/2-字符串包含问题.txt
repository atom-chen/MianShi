题目描述：
假设这有一个各种字母组成的字符串A，和另外一个字符串B，字符串里B的字母数相对少一些。什么方法能最快的查出所有小字符串B里的字母在大字符串A里都有？

1.O（n*m）的轮询方法
判断string2中的字符是否在string1中?：
String 1: ABCDEFGHLMNOPQRS
String 2: DCGSRQPO
    判断一个字符串是否在另一个字符串中，最直观也是最简单的思路是，针对第二个字符串string2中每一个字符，一一与第一个字符串string1中每个字符依次轮询比较，看它是否在第一个字符串string1中。


2.O(mlogm)+O(nlogn)+O(m+n)的排序方法
    一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。
线性扫描工作：就是判断两个有序数组的包含问题
思路：对数组B进行遍历，记录当前遍历的下标值，对于其中的每一个元素B[posB]，在A中寻找与其相等的元素，如果A[posA]<B[posB]，就继续在A中向后查找，直到找到一个>=B[posB]的，如果是等于，那么向后移动posB，检查下一个B[posB]，如果是大于，说明B中的这个元素在A中找不到，那么循环结束。
代码如下
bool CompareTwoString(string a,string b){
    int posA=0;
    int posB=0;
    while(posB<b.length()){
        while(a[posA]<a[posB]&&posA<a.length()){
            posA++;
        }
        if(a[posA]!=b[posB])
            break;
        posB++;
    }

    if(posB==b.length())
        return true;
    else
        return false;
}


3.下面给出一个更好的方案：
    假设我们有一个一定个数的字母组成字串，我给每个字母分配一个素数，从2开始，往后类推。这样A将会是2，B将会是3，C将会是5，等等。现在我遍历第一个字串，把每个字母代表的素数相乘。你最终会得到一个很大的整数，对吧？
    然后――轮询第二个字符串，用每个字母除它。如果除的结果有余数，这说明有不匹配的字母。如果整个过程中没有余数，你应该知道它是第一个字串恰好的子集了。

思路总结如下：
1.定义最小的26个素数分别与字符'A'到'Z'对应。
2.遍历长字符串，求得每个字符对应素数的乘积。
3.遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。
4.输出结果。

    至此，如上所述，上述算法的时间复杂度为O(m+n)，时间复杂度最好的情况为O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回false），n为长字串的长度，空间复杂度为O(1)。