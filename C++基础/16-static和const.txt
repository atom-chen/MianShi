1.static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。
2.起初，在C中引入关键字static是为了表示退出一个块后仍然存在的局部变量。随后，static在C中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用static关键字来表示这第二种含义。最后，C++重用了这个关键字，并赋予它与前面不同的第三种含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数(与Java中此关键字的含义相同)。

3.const修饰函数形式参数
     形式参数有输入形式参数和输出形式参数。参数用于输出时不能加const修饰，那样会使函数失去输出功能。因为const修饰的东西是不能改变的。
     const只能用于修饰输入参数。
     谈const只能用于修饰输入参数之前先谈谈C++函数的三种传递方式。
     C++函数的三种传递方式为：值传递、指针传递和引用传递。简单举例说明之，详细说明请参考别的资料。
     值传递：
       void fun(int x){
             x += 5;       //修改的只是y在栈中copy x，x只是y的一个副本，在内存中重新开辟的一块临时空间把y的值 送给了x；这样也增加了程序运行的时间，降低了程序的效率。
       }
       void main(void){
             int y = 0;
             fun(y);
             cout<</"y = /"<<y<<endl;  //y = 0;
       }
     指针传递：
        void fun(int *x){
             *x += 5;      //修改的是指针x指向的内存单元值
        }
        void main(void){
             int y = 0;
             fun(&y);
             cout<<<</"y = /"<<y<<endl;  //y = 5;
        }
      引用传递：
         void fun(int &x){
             x += 5;      //修改的是x引用的对象值 &x = y;
        }
        void main(void){
             int y = 0;
             fun(y);
             cout<<<</"y = /"<<y<<endl;  //y = 5;
        }
      看了传递方式后我们继续来谈“const只能用于修饰输入参数”的情况。

         当输入参数用“值传递”方式时，我们不需要加const修饰，因为用值传递时，函数将自动用实际参数的拷贝初始化形式参数，当在函数体内改变形式参数时，改变的也只是栈上的拷贝而不是实际参数。
         但要注意的是，当输入参数为ADT/UDT（用户自定义类型和抽象数据类型）时，应该将“值传递”改为“const &传递”，目的可以提高效率。
         例如：
            void fun(A a);//效率底。函数体内产生A类型的临时对象用于复制参数 a，但是临时对象的
                          //构造、复制、析构过程都将消耗时间。
            void fun(A const &a);//提高效率。用“引用传递”不需要产生临时对象，省了临时对象的
                                 //构造、复制、析构过程消耗的时间。但光用引用有可能改变a,所以加const


         当输入参数用“指针传递”方式时，加const修饰可防止意外修改指针指向的内存单元，起到保护作用。
         例如：
            void funstrcopy(char *strdest,const char *strsrc)//任何改变strsrc指向的内存单元，
                                                             //编译器都将报错
            些时保护了指针的内存单元，也可以保护指针本身，防止其地址改变。
         例如：
           void funstrcopy(char *strdest,const char *const strsrc)

(3)const修饰函数的返回值

     如给“指针传递”的函数返回值加const，则返回值不能被直接修改，且该返回值只能被赋值给加const修饰的同类型指针。
     例如：
        const char *GetChar(void){};
      赋值 char *ch = GetChar();//错误    const char *ch = GetChar();//正确

(4)const修饰类的成员函数(函数定义体)

     任何不会修改数据成员的函数都应用const修饰，这样当不小心修改了数据成员或调用了非const成员函数时，编译器都会报错。
     const修饰类的成员函数形式为：int GetCount(void)  const;