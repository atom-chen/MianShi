1.引用只是默认值的别名，对引用唯一的操作就是将其初始化，一旦引用初始化结束，引用就是默认值的另一种写法而已。
一定要注意：引用变量没有地址，甚至它们可能不占用任何存储空间。
所以声明引用的引用，指向引用的指针，指向引用的数组都是非法的。

2.引用和函数相结合时，有如下几种功能
a.如果一个函数返回一个引用，这说明此函数的返回值可重新赋值。
b.引用的另一个用途即让函数在其返回值之外多传递几个值，因为引用可以对引用的变量进行修改
c.指针和引用的区别，指针的内容是指向变量所在的地址，而引用就是别名而已，所以指向数组的引用保留了数组的长度，即引用会拥有所引用变量的一些性质，但是指针就仅仅是个地址，永远都是4字节（32位）。
引用变量的sizeof也占4个字节。

3.引用和指针的区别
引用只能在定义时被初始化一次，之后不可变；指针可变；
“sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的地址）的大小；

在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。

4. 引用是C++中的概念，初学者容易把引用和指针混淆一起。一下程序中，n 是m 的一个引用（reference），m是被引用物（referent）。
    int m；
    int &n = m；
    n 相当于m 的别名（绰号），对n 的任何操作就是对m 的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。所以n 既不是m 的拷贝，也不是指向m 的指针，其实n就是m 它自己。

    引用的一些规则如下：
    （1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
    （2）不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。
    （3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

    以下示例程序中，k 被初始化为i 的引用。语句k = j 并不能将k 修改成为j 的引用，只是把k 的值改变成为6.由于k 是i 的引用，所以i 的值也变成了6.
    int i = 5；
    int j = 6；
    int &k = i；
    k = j； // k 和i 的值都变成了6；

    上面的程序看起来象在玩文字游戏，没有体现出引用的价值。引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。

5.将“引用”作为函数参数有哪些特点？
（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

6.1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

7.你觉得指针和数组相同吗？讲讲你理解的指针。
1、肯定不同，指针是一块地址，而数组的分配在栈空间上的一块连续的地址，虽然他们都是指的地址，但他们的意义不同
2、指针分为两块，一是指针本身的地址，二是指针指向的地址，指针本身的地址是定义在栈上的一块地址，但这快地址里不能村数据，例如：int *p；p本身是在栈上存在的地址，但不能这样使用*p=10;而指针指向的地址可以是在栈上也可以在堆上开辟，
3、当数组做函数参数的时候会退化成指针