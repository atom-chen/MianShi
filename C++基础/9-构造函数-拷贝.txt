1.拷贝构造函数
以下情况都会调用拷贝构造函数：
（1）一个对象以值传递的方式传入函数体 
（2）一个对象以值传递的方式从函数返回 
（3）一个对象需要通过另外一个对象进行初始化。
可见，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它的唯一的一个参数是本类型的一个引用变量，该参数是const类型，不可变的。
当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：
A.一个对象以值传递的方式传入函数体 
//全局函数，传入的是对象  
void g_Fun(CExample C)  
{  
 cout<<"test"<<endl;  
}
调用g_Fun()时，会产生以下几个重要步骤：
(1).test对象传入形参时，会先会产生一个临时变量，就叫 C 吧。
(2).然后调用拷贝构造函数把test的值给C。 整个这两个步骤有点像：CExample C(test);
(3).等g_Fun()执行完后, 析构掉 C 对象。

B.一个对象以值传递的方式从函数返回
CExample g_Fun() 
{  
 CExample temp(0);  
 return temp;  
} 
当g_Fun()函数执行到return时，会产生以下几个重要步骤：
(1). 先会产生一个临时变量，就叫XXXX吧。
(2). 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);
(3). 在函数执行到最后先析构temp局部变量。
(4). 等g_Fun()执行完后再析构掉XXXX对象。 

C.一个对象需要通过另外一个对象进行初始化。


2.默认拷贝构造函数
    很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值。
    
拷贝构造函数没有处理静态数据成员。
比如一个类里有一个静态成员count，用来计算该类实例化对象的个数，如果使用默认拷贝构造函数的话，count的数据不会发生变化，所以这个时候，即当类里有静态成员的时候，要考虑自己编写拷贝构造函数。
Rect(const Rect& r)   // 拷贝构造函数  
    {  
        width = r.width;  
        height = r.height;  
        count++;          // 计数器加1  
    }  

默认拷贝构造函数是浅拷贝。


3.浅拷贝和深拷贝
　　在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。
　　深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。

4.三法则（英语：rule of three，the Law of The Big Three，The Big Three；三法则，三大定律）在 C++ 程序设计里，它是一个以设计的基本原则而制定的定律，三法则的要求在于，假如类型有明显地定义下列其中一个成员函数，那么程序员必须连其他二个成员函数也一同编写至类型内，亦即下列三个成员函数缺一不可。 [1]:

析构函数（Destructor）
复制构造函数（copy constructor）
复制赋值运算符（copy assignment operator）