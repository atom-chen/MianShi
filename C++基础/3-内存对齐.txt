1.即: 什么是字节对齐,为什么要对齐?   
    现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问  
    可以从任何地址开始, 但实际情况是在访问特定类型变量的时候经常在特定的内存地址  
    访问, 这就需要各种类型数据按照一定的规则在空间上排列, 而不是顺序的一个接一个  
    的排放,这就是对齐.  
即：对齐的作用和原因?  
    各个硬件平台对存储空间的处理上有很大的不同. 一些平台对某些特定类型的数据只能  
    从某些特定地址开始存取. 比如有些架构的CPU在访问一个没有进行对齐的变量的时候  
    会发生错误, 那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况,   
    但是最常见的是如果不按照适合其平台要求对齐数据存放进行对齐, 会在存取效率上带  
    来损失. 比如有些平台每次读都是从偶地址开始, 如果一个int型( 假设为32位系统 )如  
    果存放在偶地址开始的地方, 那么一个读周期就可以读出这32bit, 而如果存放在奇地址  
    开始的地方, 就需要2个读周期, 并对两次读出的结果的高低字节进行拼凑才能得到该  
    32bit数据.显然在读取效率上下降很多.  

2.内存对齐的规则
在具体讲内存对齐的规则之前引入一个名词：对齐系数，也叫对齐模数，每个编译器都有自己默认的对齐系数，VC6.0默认为8。程序员可以根据需要进行修改，可通过预编译指令#pragma pack(n)，n就是对齐系数，可以取1、2、4、8、16，具体对齐规则有三条，如下：
(1).数据成员的对齐规则：结构体(struct)(或者联合体(union))的数据成员，第一个数据成员放在偏移量为0的地方，以后每个数据成员按照#pragma pack(n)和数据成员中比较小的那个数对齐，也就是说，起始地址需要是这个数的倍数，具体下面会举例说明；
(2).结构体(struct)(或者联合体(union))整体对齐规则：整体的大小应该按照#pragma pack(n)和结构中最长的数据结构中，最大的那个进行，也就是，需要是这个数的倍数；
(3).如果#pragma pack(n)比结构中任何一个数据成员类型都大，则对齐系数不起任何作用。下面举例说明，环境：VS2013，32位操作系统


#include <iostream>
using namespace std;
 
struct S
{
	char a;
	int  b;
	short c;
 };
 
struct T
{
	short c;
	char  a;
	int   b;
};
 
int main()
{
	cout << "sizeof(S) is " << sizeof(S) << endl;
	cout << "sizeof(T) is " << sizeof(T) << endl;
	system("PAUSE");
	return 0;
}

代码输出结果为：
sizeof(S) is 12

sizeof(T) is 8   

编译器默认对齐系数为8：

对于结构体S，成员a是char型数据，占1字节大小，b是int型数据，占用4个字节，因为规则1，所以需要从内存偏移量为4的倍数的地方开始，因此需要a需要补上3字节无用内存，此时a占用4字节，下面是c，c是short型数据，占用2个字节，此时偏移量4+4=8，是2的倍数，符合规则1，结构体此时总大小：4+4+2=10；又根据规则2，结构体成员变量类型，最长的为4，因此结构体整体大小应该为4的倍数，因此需要c多占用2个字节，此时结构体大小为：4+4+4=12。

对于结构体T，c是short型数据，占用2个字节大小，a是char型数据，占用1个字节大小，起始偏移量3，是1的倍数，满足，此时大小为：2+1=3，b为int型数据，占用4字节，起始偏移量为3，显然不满足规则1，需要b补充1个字节，此时起始偏移量为2+2=4，满足规则1，此时结构体T的大小为：2+2+4=8；又根据规则2，结构体成员变量类型中最长的为4，结构体内存大小满足，因此，最终大小为8。


3.【在考虑内存对齐时的编程技巧】  
    在编程的时候要考虑节约空间的话, 那么我们只需要假定结构的首地址是0,  然后各个  
    变量按照上面的原则进行排列即可, 基本的原则就是把结构中的变量按照类型大小从小  
    到大声明,尽量减少中间的填补空间.