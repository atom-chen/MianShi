1.delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套

2.对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。

3.1.内存释放
（1）针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可 如：
   int *a = new int[10];
   delete a;
   delete [] a;
   此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，
   它直接通过指针可以获取实际分配的内存空间
（2）. 针对类Class，两种方式体现出具体差异 
   当你通过下列方式分配一个类对象数组：
所以总结下就是，如果ptr代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么：
   delete   ptr   代表用来释放内存，且只用来释放ptr指向的内存。 
   delete[]   rg   用来释放rg指向的内存，！！还逐一调用数组中每个对象的destructor！！
   对于像int/char/long/int*/struct等等简单数据类型，由于对象没有destructor，所以用delete 和delete [] 是一样的！但是如果是C++对象数组就不同了！

不过不管使用delete还是delete[]那三个对象的在内存中都被删除，既存储位置都标记为可写，但是使用delete的时候只调用了pbabe[0]的析构函数，而使用了delete[]则调用了3个Babe对象的析构函数。你一定会问，反正不管怎样都是把存储空间释放了，有什么区别。答：关键在于调用析构函数上。此程序的类没有使用操作系统的系统资源（比如：Socket、File、Thread等），所以不会造成明显恶果。如果你的类使用了操作系统资源，单纯把类的对象从内存中删除是不妥当的，因为没有调用对象的析构函数会导致系统资源不被释放，